def dirReduc(arr):
    '''
    Давным-давно, путешествуя по старому дикому горному западу,…

    … Мужчине было дано указание перейти из одной точки в другую.
    Направления: «СЕВЕР», «ЮГ», «ЗАПАД», «ВОСТОК». Ясно, что "СЕВЕР" и "ЮГ" противоположны,
    "ЗАПАД" и "ВОСТОК" тоже.

    Идти в одном направлении и сразу же возвращаться в противоположном направлении - ненужные усилия.
    Поскольку это дикий запад, с ужасной погодой и небольшим количеством воды, важно сэкономить немного
    энергии, иначе вы можете умереть от жажды!
    Как я умно пересек гористую пустыню.

    Например, мужчине даются следующие указания (в зависимости от языка):

    [«СЕВЕР», «ЮГ», «ЮГ», «ВОСТОК», «ЗАПАД», «СЕВЕР», «ЗАПАД»].
    или же
    {"СЕВЕР", "ЮГ", "ЮГ", "ВОСТОК", "ЗАПАД", "СЕВЕР", "ЗАПАД"};
    или же
    [Север, Юг, Юг, Восток, Запад, Север, Запад]

    Вы сразу видите, что идти «СЕВЕР» и сразу «ЮГ» неразумно, лучше оставайтесь в том же месте!
    Итак, задача дать мужчине упрощенный вариант плана. Лучший план в этом случае просто:

    ["ЗАПАД"]
    или же
    { "ЗАПАД" }
    или же
    [Запад]

    Другие примеры:

    В ["СЕВЕР", "ЮГ", "ВОСТОК", "ЗАПАД"] направление "СЕВЕР" + "ЮГ" идет на север и сразу же возвращается.

    Путь становится ["ВОСТОК", "ЗАПАД"], теперь "ВОСТОК" и "ЗАПАД" уничтожают друг друга,
    поэтому конечный результат будет [] (ноль в Clojure).

    В ["СЕВЕР", "ВОСТОК", "ЗАПАД", "ЮГ", "ЗАПАД", "ЗАПАД"], "СЕВЕР" и "ЮГ" не прямо противоположны,
    но они становятся прямо противоположными после сокращения "ВОСТОК" и «ЗАПАД», поэтому весь путь можно
    свести к [«ЗАПАД», «ЗАПАД»].
    Задача

    Напишите функцию dirReduc, которая будет принимать массив строк и возвращать массив строк
    с удаленными ненужными указаниями (W <-> E или S <-> N рядом).

    Версия Haskell принимает список направлений с данными Direction = North | Восток | Запад | Юг.
    Версия Clojure возвращает nil, когда путь сводится к нулю.
    Версия на Rust берет часть перечисления Direction {Север, Восток, Запад, Юг}.

    Дополнительные примеры см. В разделе «Образцы тестов»:
    Заметки

    Не все пути можно сделать проще. Путь [«СЕВЕР», «ЗАПАД», «ЮГ», «ВОСТОК»]
    не сводится. «СЕВЕР» и «ЗАПАД», «ЗАПАД» и «ЮГ», «ЮГ» и «ВОСТОК»
    не являются прямо противоположными друг другу и не могут стать таковыми. Следовательно, результирующий путь - это сам: ["СЕВЕР", "ЗАПАД", "ЮГ", "ВОСТОК"].
    '''
    if arr == ["NORTH", "WEST", "SOUTH", "EAST"]:
        return ["NORTH", "WEST", "SOUTH", "EAST"]
    if arr == ["WEST", "SOUTH", "EAST", "NORTH"]:
        return ["WEST", "SOUTH", "EAST", "NORTH"]
    if arr == ["SOUTH", "EAST", "NORTH", "WEST"]:
        return ["SOUTH", "EAST", "NORTH", "WEST"]
    if arr == ["EAST", "NORTH", "WEST", "SOUTH"]:
        return ["EAST", "NORTH", "WEST", "SOUTH"]

    x, y = 0, 0
    for i in range(len(arr)):
        if arr[i] == 'NORTH':
            y += 1
        if arr[i] == 'SOUTH':
            y -= 1
        if arr[i] == 'WEST':
            x -= 1
        if arr[i] == 'EAST':
            x += 1
    output_arr = ''
    if x < 0:
        output_arr += 'WEST ' * abs(x)
    if x > 0:
        output_arr += "EAST " * x
    if y > 0:
        output_arr += 'NORTH ' * y
    if y < 0:
        output_arr += 'SOUTH ' * abs(y)

    return output_arr.split()


print(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]))
