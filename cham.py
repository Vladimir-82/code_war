def dirReduc(arr):
    '''
    Давным-давно, путешествуя по старому дикому горному западу,…

    … Мужчине было дано указание перейти из одной точки в другую.
    Направления: «СЕВЕР», «ЮГ», «ЗАПАД», «ВОСТОК». Ясно, что "СЕВЕР" и "ЮГ" противоположны,
    "ЗАПАД" и "ВОСТОК" тоже.

    Идти в одном направлении и сразу же возвращаться в противоположном направлении - ненужные усилия.
    Поскольку это дикий запад, с ужасной погодой и небольшим количеством воды, важно сэкономить немного
    энергии, иначе вы можете умереть от жажды!
    Как я умно пересек гористую пустыню.

    Например, мужчине даются следующие указания (в зависимости от языка):

    [«СЕВЕР», «ЮГ», «ЮГ», «ВОСТОК», «ЗАПАД», «СЕВЕР», «ЗАПАД»].
    или же
    {"СЕВЕР", "ЮГ", "ЮГ", "ВОСТОК", "ЗАПАД", "СЕВЕР", "ЗАПАД"};
    или же
    [Север, Юг, Юг, Восток, Запад, Север, Запад]

    Вы сразу видите, что идти «СЕВЕР» и сразу «ЮГ» неразумно, лучше оставайтесь в том же месте!
    Итак, задача дать мужчине упрощенный вариант плана. Лучший план в этом случае просто:

    ["ЗАПАД"]
    или же
    { "ЗАПАД" }
    или же
    [Запад]

    Другие примеры:

    В ["СЕВЕР", "ЮГ", "ВОСТОК", "ЗАПАД"] направление "СЕВЕР" + "ЮГ" идет на север и сразу же возвращается.

    Путь становится ["ВОСТОК", "ЗАПАД"], теперь "ВОСТОК" и "ЗАПАД" уничтожают друг друга,
    поэтому конечный результат будет [] (ноль в Clojure).

    В ["СЕВЕР", "ВОСТОК", "ЗАПАД", "ЮГ", "ЗАПАД", "ЗАПАД"], "СЕВЕР" и "ЮГ" не прямо противоположны,
    но они становятся прямо противоположными после сокращения "ВОСТОК" и «ЗАПАД», поэтому весь путь можно
    свести к [«ЗАПАД», «ЗАПАД»].
    Задача

    Напишите функцию dirReduc, которая будет принимать массив строк и возвращать массив строк
    с удаленными ненужными указаниями (W <-> E или S <-> N рядом).

    Версия Haskell принимает список направлений с данными Direction = North | Восток | Запад | Юг.
    Версия Clojure возвращает nil, когда путь сводится к нулю.
    Версия на Rust берет часть перечисления Direction {Север, Восток, Запад, Юг}.

    Дополнительные примеры см. В разделе «Образцы тестов»:
    Заметки

    Не все пути можно сделать проще.
    Путь [«СЕВЕР», «ЗАПАД», «ЮГ», «ВОСТОК»]
    не сводится. «СЕВЕР» и «ЗАПАД», «ЗАПАД» и «ЮГ», «ЮГ» и «ВОСТОК»
    не являются прямо противоположными друг другу и не могут стать таковыми. Следовательно, результирующий путь - это сам: ["СЕВЕР", "ЗАПАД", "ЮГ", "ВОСТОК"].
    '''
    ROUND = [
        ["NORTH", "WEST", "SOUTH", "EAST"],
        ["WEST", "SOUTH", "EAST", "NORTH"],
        ["SOUTH", "EAST", "NORTH", "WEST"],
        ["EAST", "NORTH", "WEST", "SOUTH"],
        ["NORTH", "WEST", "SOUTH", "EAST"][::-1],
        ["WEST", "SOUTH", "EAST", "NORTH"][::-1],
        ["SOUTH", "EAST", "NORTH", "WEST"][::-1],
        ["EAST", "NORTH", "WEST", "SOUTH"][::-1]
    ]
    x, y = 0, 0
    optimiz_path = []
    for direction in range(0, len(arr) - 3):
        slc = arr[direction:direction + 4]
        if slc in ROUND:
            optimiz_path.extend(arr[direction:direction + 4])
            arr[direction:direction + 4] = []
    if arr:
        for i in range(len(arr)):
            if arr[i] == 'NORTH':
                y += 1
            if arr[i] == 'SOUTH':
                y -= 1
            if arr[i] == 'WEST':
                x -= 1
            if arr[i] == 'EAST':
                x += 1
            output_arr = ''
            if x < 0:
                output_arr += 'WEST ' * abs(x)
            if x > 0:
                output_arr += "EAST " * x
            if y > 0:
                output_arr += 'NORTH ' * y
            if y < 0:
                output_arr += 'SOUTH ' * abs(y)


        optimiz_path.extend(output_arr.split())




    return optimiz_path



print(dirReduc(['NORTH', 'EAST', 'NORTH', 'EAST', 'NORTH', 'WEST', 'SOUTH', 'SOUTH', 'SOUTH', 'WEST', 'NORTH', 'EAST', 'EAST', 'NORTH', 'WEST', 'SOUTH', 'EAST']))